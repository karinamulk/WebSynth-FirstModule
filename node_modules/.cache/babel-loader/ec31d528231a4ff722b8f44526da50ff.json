{"ast":null,"code":"export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n  return (nativeAudioNode, whenConnected, whenDisconnected) => {\n    const connections = new Set();\n\n    nativeAudioNode.connect = (connect => {\n      // tslint:disable-next-line:invalid-void no-inferrable-types\n      return function (destination) {\n        let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        const wasDisconnected = connections.size === 0;\n\n        if (isNativeAudioNode(destination)) {\n          // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n          connect.call(nativeAudioNode, destination, output, input);\n          insertElementInSet(connections, [destination, output, input], connection => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n\n          if (wasDisconnected) {\n            whenConnected();\n          }\n\n          return destination;\n        }\n\n        connect.call(nativeAudioNode, destination, output);\n        insertElementInSet(connections, [destination, output], connection => connection[0] === destination && connection[1] === output, true);\n\n        if (wasDisconnected) {\n          whenConnected();\n        }\n\n        return;\n      };\n    })(nativeAudioNode.connect);\n\n    nativeAudioNode.disconnect = (disconnect => {\n      return (destinationOrOutput, output, input) => {\n        const wasConnected = connections.size > 0;\n\n        if (destinationOrOutput === undefined) {\n          disconnect.apply(nativeAudioNode);\n          connections.clear();\n        } else if (typeof destinationOrOutput === 'number') {\n          // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n          disconnect.call(nativeAudioNode, destinationOrOutput);\n\n          for (const connection of connections) {\n            if (connection[1] === destinationOrOutput) {\n              connections.delete(connection);\n            }\n          }\n        } else {\n          if (isNativeAudioNode(destinationOrOutput)) {\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n          } else {\n            // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n            disconnect.call(nativeAudioNode, destinationOrOutput, output);\n          }\n\n          for (const connection of connections) {\n            if (connection[0] === destinationOrOutput && (output === undefined || connection[1] === output) && (input === undefined || connection[2] === input)) {\n              connections.delete(connection);\n            }\n          }\n        }\n\n        const isDisconnected = connections.size === 0;\n\n        if (wasConnected && isDisconnected) {\n          whenDisconnected();\n        }\n      };\n    })(nativeAudioNode.disconnect);\n\n    return nativeAudioNode;\n  };\n};","map":null,"metadata":{},"sourceType":"module"}